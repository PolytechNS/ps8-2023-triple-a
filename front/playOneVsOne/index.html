<!DOCTYPE html>
<html lang="en">

  <head>
    
    <title>My Game</title>
    <!-- <link rel="stylesheet" href="style.css"> -->
    <style>
      body {
    font-family: "Helvetica Neue", sans-serif;
    margin: 0;
    padding: 0;
  }
  
  input {
    outline: none;
    font-size: 1.0rem;
    padding: 0 5px;
  }
  
  button {
    text-transform: uppercase;
    font-size: 0.8rem;
    padding: 3px 15px;
    color: white;
    line-height: 25px;
    background-color: #00bcd4;
    border: none;
    border-radius: 2px;
    cursor: pointer;
    box-shadow: rgba(0, 0, 0, 0.12) 0 1px 6px, rgba(0, 0, 0, 0.12) 0 1px 4px;
    transition: all 150ms ease-in;
    outline: none;
  }
  
  button:hover {
    background-color: #79d7e4;
  }
  
  button.turn:hover {
    background-color: #eaeaea;
  }
  
  ul {
    list-style: none;
    margin: 0;
    padding: 0;
    border-bottom: 1px solid lightgrey;
    overflow-y: scroll;
  }
  
  li {
    padding: 10px 10px 10px 10px;
  }
  
  canvas {
    display: block;
    margin: 10px auto;
  }
  
  .controls-wrapper {
    background-color: rgb(255, 255, 255);
    width: 400px;
    margin: 20px auto;
    border: 1px solid lightgrey;
  }
  
  .chat-wrapper {
    padding: 10px;
  }
  
  .chat-wrapper form {
    display: flex;
  }
  
  .chat-wrapper form input {
    font-size: 1.0rem;
    margin: 0 10px 0 0;
    padding: 0 5px;
    flex-grow: 1;
  }
  
  .chat-wrapper form button {
    width: 80px;
  }
  
  #events {
    height: 150px;
  }
  
  body {
    font-family: Arial, Helvetica, sans-serif;
    text-align: center;
}

.box {
  width: auto;
  height: 2cm;
  margin-left: auto;
  margin-right: auto;
}

/*the image should be 50% of the box*/
image {
  width: 50%;
  height: 50%; 
}

#board {
    margin-top: 1.5cm;
    height: 420px;
    width: 480px;
    background-color: rgb(129, 196, 235);
    border: 5px solid navy;

    border-radius: 5%;
    display: flex;
    flex-wrap: wrap;

    margin-left: auto;
    margin-right: auto;    
}

.tile {
  height: 56px;
  width: 56px;
  margin: 5px;

  /* Circle */
  background-color: rgb(183, 226, 229);
  border-radius: 100%;
  border: 3px solid navy;
}

#saved-games {
  position: fixed;
  top: 0;
  left: 0;
  width: 250px;
  height: 100%;
  background-color: #81C4EB;
  padding: 20px;
  overflow-y: auto;
}

#games-list {
  list-style: none;
  overflow-y: scroll;
  margin: 0;
  padding: 0;
}

.game-button {
  display: block;
  width: 100%;
  font-weight: bold;
  color: black;
  margin-right: 10px;
  text-transform: lowercase;
  margin-bottom: 5px;
  padding: 10px;
  background-color: #DFE9F5;
  border: 1px solid #ccc;
  border-radius: 10%;
  cursor: pointer;
}

.game-button:hover {
  background-color: #91c0f8;
}
.game-container {
  display: flex;
  flex-direction: column;
  align-items: center;
}

.game-button {
  margin-bottom: 8px;
}

.red-piece {
    background-color: red;
}

.yellow-piece {
    background-color: yellow;
}

*{
  margin: 0;
  padding: 0;
  box-sizing: border-box;
  font-family: 'Poppins', sans-serif;
}

body {
  background-color: #dfe9f5;
}

.wrapper {
  width: 330px;
  padding: 2rem 1em;
  margin: 50px auto;
  background-color: #fff;
  border-radius: 6px;
  text-align: center;
  box-shadow: 0 20 30px;
}

h1 {
  font-size: 2rem;
  margin-bottom: 1.2rem;
  color: #0f1114;
}

form input {
  width: 92%;
  outline: none;
  border: 1px solid #fff;
  padding: 12px 20px;
  margin-bottom: 10px;
  border-radius: 20px;
  background: #e4e4e4;
}

button {
  font-size: 1rem;
  margin-top: 1.8rem;
  padding: 10px 0px;
  border-radius: 20px;
  outline: none;
  border: none;
  width: 90%;
  color: #fff;
  cursor: pointer;
  background: rgb(17, 107, 143);
}

button:hover {
  background: rgb(17, 187, 143, 0.877);
}

input:focus {
  border: 1px solid rgb(192, 192, 192);
}

.terms {
  margin-top: 0.2rem;
}

.terms input {
  height: 1em;
  width: 1em;
  vertical-align: middle;
  cursor: pointer;
}

.terms label {
  font-size: 0.7rem;
}

.terms a {
  color: rgb(17, 187, 143);
  text-decoration: none;
}

.member {
  margin-top: 1.4rem;
  font-size: 0.8rem;
  columns: #636363;
}

.member a {
  color: rgb(17, 107, 143);
  text-decoration: none;
}

.recover {
  text-align: right;
  font-size: 0.7rem;
  margin: 0.3rem 1.4rem 0 0;
}

.recover a {
  text-decoration: none;
  color: #464647;
}

h1 {
  text-align: center;
  padding-top: 15px;
}

.back {
  width: 600px;
  text-align: center;
  height: auto;
  border: 2px solid;
  justify-content: center;
  text-align: center;
  margin: 1cm;
  padding: 1cm;
  box-shadow: tomato;
  border-radius: 10px;
  background-color: #fafafa;
  margin-left: auto;
  margin-right: auto;
}

.button {
  height: auto;
  width: auto;
  text-align: center;
  text-transform: lowercase;
  background-image: url("../images/Board-image.jpg");
  background-color: #62b4e4;
  color: #1751bb;
}

.hidden {
  display: none;
}

.shown {
  display: block;
}

    </style>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.3.0/css/all.min.css"  />

    <!-- <script src="OnevOne.js"></script> -->

  </head>

  <body>
  <!-- <div id="saved-games">
    <h2>Saved Games</h2>
    <ul id="games-list"></ul>
  </div> -->
    
    <button id = 'newGame'>New Game</button>
    <button id = 'joinGame'>Join Game</button>
    <input type="text" id="textGameId">
    <div id="divContainer"></div>

    <div id="board"></div>

    <div class="controls-wrapper">
      <ul id="chat"></ul>
      <div class="controls">
        <div class="chat-wrapper">
          <form id="chat-form">
            <input id="chat" autocomplete="off" title="chat"/>
            <button id="say">Say</button>
            <br>
            <!-- <a> <button class="button" id ="saveButton" onclick="saveGame(event,'local') " >SaveGame</button></a> -->
            <!-- <a> <button class="button" onclick="restoreSavedGame(event) " >Restore Game</button></a>-->
          </form>
        </div>
      </div>
    </div>

    <script>
      /// trace de sockets

/**
 * 
const log = (text) => {
  const parent = document.querySelector('#chat');
  const el = document.createElement('li');
  el.innerHTML = text;

  parent.appendChild(el);
  parent.scrollTop = parent.scrollHeight;
};

const onChatSubmitted = (sock) => (e) => {
  e.preventDefault();

  const input = document.querySelector('#chat');
  const text = input.value;
  input.value = '';
  // Send to all connected users
  sock.emit('message', text);
};

(() => {
  const sock = io();
  sock.on('message', (text) => log(text));

  document
    .querySelector('#chat-form')
    .addEventListener('submit', onChatSubmitted(sock));
})();

*/

var playerRed = "RED";
var playerYellow = "YELLOW";
var playerToStart;
playerToStart = playerRed;
var currentPlayer = playerToStart;
var previousPlayer = null;

var gameOver = false;
var winner = null;
window.resume = false;

// Stoque la matrice du jeu dont les éléments sont, 
// si remplis, soit 'RED' soit 'YELLOW'
var boardMatrix;

// Stoque la matrice du jeu dont les éléments sont, 
// si remplis, sont les tiles du DOM
var boardGame;

var rows = 6;
var columns = 7;

const localHost = 'localhost';
const url = '15.236.164.81';
let localHostOrUrl;

function chooselocalHostOrUrl(l) {
    if ( l == 2 ) {
        localHostOrUrl = localHost;
    }
    else if ( l == 1 ) {
        localHostOrUrl = url;
    }
}

// 1 : URL | 2 : Localhost
chooselocalHostOrUrl(2);

window.onload = function() {
    main();
}

function main() {
    setBoard();
}

function setBoard() {
    boardGame = document.getElementById("board");
    boardMatrix = [];
    for (let r = 0; r < rows; r++) {
      boardMatrix[r] = [];
      for (let c = 0; c < columns; c++) {
        boardMatrix[r][c] = ' ';
        let tile = document.createElement("div");
        tile.id = r.toString() + "-" + c.toString();
        tile.classList.add("tile");
        boardGame.appendChild(tile);
        divv.style.visibility = "hidden";
      }
    }
    return boardGame;
}

function getTile(i, j) {
    let target = document.getElementById(i.toString() + "-" + j.toString());;
    return target;
}

const divv = document.getElementById("board");

function getTileId(i, j) {
    return getTile(i, j).id;
}

function getCoordinatesOfTheClickedTile() {
    return new Promise((resolve) => {
        boardGame.addEventListener("click", function(event) {
            let target = event.target;
            if (target.classList.contains("tile")) {
                let tileId = target.id;
                let row = tileId[0];
                let column = tileId[2];
                resolve([row, column]);
            }
        });
    });
}

function getAvailableCoordinates() {
    let availableCoordinates = [];
    for (let i = 0; i < boardGame.length; i++) {
        for (let j = 0; j < boardGame[i].length; j++) {
            if (boardGame[i][j] == ' ') {
                availableCoordinates.push([i, j]);
            }
        }
    }
    return availableCoordinates;
}

// function fillTheClickedTile() {
//     boardGame.addEventListener("click", function(event) {
//         let target = event.target;
//         if (target.classList.contains("tile")) {

//             let coords = target.id.split("-");
//             let row = parseInt(coords[0]);
//             let column = parseInt(coords[1]);

//             let adjustedCoords = adjustCoordinates(row, column);

//             row = adjustedCoords[0];
//             column = adjustedCoords[1];

//             const payLoad = {
//                 "method": "play",
//                 "clientId": clientId,
//                 "gameId": gameId,
//                 "color": currentPlayer,
//                 "row": row,
//                 "column": column
//             }
//             ws.send(JSON.stringify(payLoad));
//             fillTile(row, column);
//         }
//     });
// }

function fillTile(i, j) {
    if (gameOver) {
        return;
    }
    if ( currentPlayer == playerRed ) {
        getTile(i, j).classList.add("red-piece");
    }
    else {
        getTile(i, j).classList.add("yellow-piece");
    }
    boardMatrix[i][j] = currentPlayer;
    updateTurn();
    // console.log('Tile',  [i, j], "has been filled with", boardMatrix[i][j]);
    checkWinner();
}

function updateTurn() {
    if ( currentPlayer == playerRed ) {
        currentPlayer = playerYellow;
    }
    else {
        currentPlayer = playerRed;
    }
}

function adjustCoordinates(row, column) {
    let adjustedRow = row;
    let adjustedColumn = column;
    let columnIsFull = false;

    for ( let i = rows - 1; i >= 0; i-- ) {
        if ( boardMatrix[i][adjustedColumn] == ' ' ) {
            adjustedRow = i;
            break;
        }
    }

    if ( adjustedRow < 0 ) {
        columnIsFull = true;
        console.log(columnIsFull);
        return;
    }

    return [adjustedRow, adjustedColumn];
}

function getIdOfClickedTile() {
    return new Promise((resolve) => {
        boardGame.addEventListener("click", function(event) {
            let target = event.target;
            if (target.classList.contains("tile")) {
                let tileId = target.id;
                resolve(tileId);
            }
        });
    });
}

function iterateOverTiles() {
    let tiles = boardGame.getElementsByClassName("tile");
    for (let i = 0; i < tiles.length; i++) {
        console.log(tiles[i]);
    }
}

function checkWinner() {
    for (let r = 0; r < rows; r++) {
        for (let c = 0; c < columns; c++) {
            if (boardMatrix[r][c] != ' ') {
                if (checkHorizontal(r, c) || checkVertical(r, c) || checkDiagonal(r, c)) {
                    gameOver = true; 
                    winner = currentPlayer;
                    console.log(currentPlayer + " wins !");
                }
                updateTurn();
            }
        }
    }
    return winner;
}

function checkDiagonal(r, c) {
    if (r < 3 && c < 4) {
        if (boardMatrix[r][c] === boardMatrix[r+1][c+1] && boardMatrix[r][c] === boardMatrix[r+2][c+2] && boardMatrix[r][c] === boardMatrix[r+3][c+3]) {
            return true;
        }
    }
    if (r < 3 && c > 2) {
        if (boardMatrix[r][c] === boardMatrix[r+1][c-1] && boardMatrix[r][c] === boardMatrix[r+2][c-2] && boardMatrix[r][c] === boardMatrix[r+3][c-3]) {
            return true;
        }
    }
    return false;
}

function checkHorizontal(r, c) {
    if (c < 4) {
        if (boardMatrix[r][c] == boardMatrix[r][c+1] && boardMatrix[r][c] == boardMatrix[r][c+2] && boardMatrix[r][c] == boardMatrix[r][c+3]) {
            return true;
        }
    }
    return false;
}

function checkVertical(r, c) {
    if (r < 3) {
        if (boardMatrix[r][c] === boardMatrix[r+1][c] && boardMatrix[r][c] === boardMatrix[r+2][c] && boardMatrix[r][c] === boardMatrix[r+3][c]) {
            return true;
        }
    }
    return false;
}

function boardMatrixCopy(){
    let copy = [];
    for (let i = 0; i < rows ; i++) {
        copy[i] = [];
        for(let j = 0; j < columns ; j++) {
            copy[i][j] = boardMatrix[i][j];
        }
    }
    return copy;
}

// document.getElementById("saveButton").addEventListener("click",function(){saveGame("local")});

async function saveGame(event, gameType) {

    event.preventDefault();

    console.log("in saveGame")
    let token = localStorage.getItem("token");
    const savingDate = new Date();

    console.log(token);
    const tab = {
        gameType: gameType,
        tab: boardMatrixCopy(),
        playerToPlay: currentPlayer,
        userToken: token,
        date : savingDate.toLocaleDateString()+ " " +  savingDate.toLocaleTimeString()
    };
    console.log(tab)

    try {
        const response = await fetch('http://' + localHostOrUrl + ':8000/api/game', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(tab)
        });

        if(response.ok) {
            console.log("im in" , response.data);
            console.log("tab ", response.tab);
            console.log("tab ", tab);
            window.location.href = '../../modeGamePage/playersChooseColors.html'

        }
        else{
            console.log("error");
        }
    } catch (err) {
        console.log(err);
    }
}

async function resumeGame() {
    let redirect = document.getElementById("resume-link");
    redirect.href ="../playOneVsOne/index.html" ;
}

async function getSavedGames() {

    const token = localStorage.getItem("token");
    const response = await fetch('http://' + localHostOrUrl + ':8000/api/game/list', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({ token })
    });
    if (response.ok) {
        const games = await response.json();
        const gamesList = document.getElementById('games-list');
        gamesList.innerHTML = '';
        if (games.length === 0) {
            gamesList.innerHTML = '<li>No saved games found.</li>';
        } else {
            for (let i = 0; i < games.length; i++) {
                const game = games[i];
                const gameItem = document.createElement('li');
                // gameItem.innerHTML = `<button data-game="${game._id}" class="game-button">local - ${game.date}</button>`;
                gameItem.innerHTML = `
                                        <div class="game-container">
                                            <button data-game="${game._id}" class="game-button">local - ${game.date}</button>
                                            <i class="gg-trash" data-game="${game._id}"></i>
                                        </div>
    `;
                gamesList.appendChild(gameItem);
            }
            document.querySelectorAll('.game-button').forEach(button => button.addEventListener('click', restoreSavedGame));
            document.querySelectorAll('.gg-trash').forEach(icon => icon.addEventListener('click', deleteSavedGame));

        }
    } else {
        console.log('Failed to retrieve saved games');
    }
}

async function restoreSavedGame(event) {
    event.preventDefault();
    const gameId = event.target.dataset.game;
    console.log("this is the game id : ", gameId);
    const token = localStorage.getItem("token");
    const response = await fetch('http://' + localHostOrUrl + ':8000/api/game/retrieve/${gameId}', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({ _id: gameId })
    });
    if (response.ok) {
        const gameData = await response.json();
        if (gameData && gameData.tab) {
            // Clear the board
            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < columns; j++) {
                    getTile(i, j).classList.remove("red-piece", "yellow-piece");
                }
            }
            // Set boardMatrix to gameData.tab
            boardMatrix = gameData.tab;
            console.log("current player : ", currentPlayer);


            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < columns; j++) {
                    if (boardMatrix[i][j] === playerRed) {
                        getTile(i, j).classList.add("red-piece");
                    }
                    if (boardMatrix[i][j] === playerYellow) {
                        getTile(i, j).classList.add("yellow-piece");
                    }
                }
            }
            // Set currentPlayer to gameData.playerToPlay
            currentPlayer = gameData.playerToPlay;
            console.log("Game resumed:", boardMatrix);
        } else {
            console.log('No game data found for user');
            console.log('gameData:', gameData);
            console.log('gameData state:', gameData.gameState);
            console.log('gameData tab:', gameData.tab);
            console.log('gameData tab:', gameData._id);
        }
    } else {
        console.log('Failed to retrieve game data');
    }
}
async function deleteSavedGame(event) {

    event.preventDefault();

    const gameId = event.target.getAttribute('data-game');
    console.log("this is the game id : ", gameId);
    const token = localStorage.getItem("token");
    const response = await fetch('http://' + localHostOrUrl + ':8000/api/game/delete/${gameId}', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({ _id: gameId })
    });
    if (response.ok) {
        // If the game was successfully deleted, remove the corresponding HTML element
        event.target.parentElement.remove();
        console.log("this is the game id : ", gameId);


    } else {
        console.log('Failed to delete saved game');
    }
}

// Call getSavedGames when the page loads
getSavedGames();

//////////////////// Server Connection Manager ////////////////////

let clientId = null;
let gameId = null;
let playerColor = null;

let room = {}

let ws = new WebSocket('ws://' + localHostOrUrl + ':9090');
const newGame = document.getElementById('newGame');
const joinGame = document.getElementById('joinGame');
const textGameId = document.getElementById('textGameId');
const divPlayers = document.getElementById('divPlayers');

// wiring events
joinGame.addEventListener('click', e => {

    if ( gameId === null ) {
        gameId = textGameId.value;
    }

    let board = document.getElementById('board');
    board.style.visibility = "visible";
    
    const payLoad = {
        "method": "joinGame",
        "clientId": clientId,
        "gameId": gameId
    }

    ws.send(JSON.stringify(payLoad));

})

newGame.addEventListener('click', e => {

    const payLoad = {
        "method": "createGame",
        "clientId": clientId
    }

    ws.send(JSON.stringify(payLoad));

})

var numberOfCreatedGames;

ws.onmessage = message => {
    // I the client receive a message from the server !
    const response = JSON.parse(message.data);

    // A new connection to the server
    if ( response.method === "connect" ) {
      clientId = response.clientId;
      console.log("Client ID : ", clientId, " set successfully !");
      numberOfCreatedGames = Object.keys(response.games).length;
      console.log("The number of created games is : ", numberOfCreatedGames);
      for ( let g in response.games ) {
        room = {
          id: g.id,
          currentPlayer: g.clients[0].clientId,
        }
      }
    }

    // create a new game
    if ( response.method === "createGame" ) {
        gameId = response.game.id;
        console.log("game succesfully created with id : ", gameId + " | by client : " + clientId);
    }

    // upadate the game state
    if ( response.method === "updateGameState" ) {
      if (!response.game.gameState) return;
      let i = 0;
      // console.log("----- Update number : ", i++, " -----");
      // console.log("FROM CLIENT : before update ", boardMatrix);
      const state = response.game.gameState;
      for ( let i = 0; i < rows; i++ ) {
        for ( let j = 0; j < columns; j++ ) {
          if ( state[i][j] === playerRed ) {
            fillTile(i, j);
          }
          if ( state[i][j] === playerYellow ) {
            fillTile(i, j);
          }
        }
      }
      // console.log("FROM CLIENT : after update ", boardMatrix);
    }

    // join a game
    if ( response.method === "joinGame" ) {
        boardGame.addEventListener("click", function(event) {
        let target = event.target;
        if (target.classList.contains("tile")) {

            let coords = target.id.split("-");
            let row = parseInt(coords[0]);
            let column = parseInt(coords[1]);

            let adjustedCoords = adjustCoordinates(row, column);

            row = adjustedCoords[0];
            column = adjustedCoords[1];

            const payLoad = {
                "method": "play",
                "clientId": clientId,
                "gameId": response.game.id,
                "color": currentPlayer,
                "row": row,
                "column": column
            }
            ws.send(JSON.stringify(payLoad));
            fillTile(row, column);
            console.log("Board : ", boardMatrix);
          }
        });
        console.log("game succesfully joined with id : ", gameId + " | by client : " + clientId);
    }
}

generateDivs();

function generateDivs() {
  var numDivs = numberOfCreatedGames;
  var divContainer = document.getElementById("divContainer");
  console.log("ROOOM: ", numDivs);
  for (var i = 1; i <= numDivs; i++) {
    var newDiv = document.createElement("div");
    newDiv.innerHTML = "Game ID : " + room[i].id;
    divContainer.appendChild(newDiv);
  }
}

    </script>

  </body>

</html>